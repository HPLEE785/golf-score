<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>È´òÁàæÂ§´ÂàÜÊï∏Á¥ÄÈåÑÂç° - v79 ÁçéÁõÉ‰ΩçÁΩÆ‰øÆÂæ©Áâà</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        /* =========================================
           CSS Ê®£ÂºèË°® (v79)
           ========================================= */
        body { font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; background-color: #f4f7f6; padding: 5px; padding-bottom: 300px; user-select: none; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        
        /* ÊéßÂà∂Èù¢Êùø */
        .main-controls { max-width: 100%; margin: 0 auto 10px auto; background: #fff; padding: 8px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; align-items: center; flex-wrap: wrap; gap: 6px; font-size: 1em; }
        .control-group { display: flex; align-items: center; gap: 4px; }
        .label-text { font-weight: bold; color: #333; font-size: 0.9em; }
        
        .action-btn { background-color: #2c3e50; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 1em; cursor: pointer; }
        .zone-select-btn { background-color: #27ae60; color: white; border: none; padding: 6px 12px; border-radius: 20px; font-weight: bold; cursor: pointer; font-size: 1.1em; min-width: 120px; white-space: nowrap; text-align: center; }
        .btn-reset { background-color: #7f8c8d; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9em; font-weight: bold; }
        .edit-toggle-label { display: flex; align-items: center; font-size: 0.9em; color: #c0392b; font-weight: bold; border: 1px solid #c0392b; padding: 4px 8px; border-radius: 4px; background: #fff; }

        /* Ë°®Ê†ºÂÆπÂô® */
        .card-container { max-width: 100%; margin: 0 auto 15px auto; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; overflow-x: auto; }
        
        /* Ê®ôÈ°åÂçÄÂüü */
        .zone-header { 
            background-color: #2e7d32; 
            color: #FFFFFF;            
            padding: 8px 12px; 
            font-weight: bold; 
            display: flex; 
            flex-direction: column; 
            gap: 4px; 
        }
        
        .header-top { display: flex; flex-wrap: wrap; align-items: baseline; gap: 8px; }
        .zone-title-text { font-size: 1.3em; white-space: nowrap; }
        .summary-info { font-size: 0.95em; color: #FFFFFF; font-weight: normal; opacity: 0.9; }

        /* Ë¥èÂÆ∂Á∂≤Ê†º */
        .winner-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 4px 10px;
            width: 100%;
            margin-top: 4px; 
            padding-top: 4px; 
            border-top: 1px dashed rgba(255,255,255,0.4); 
        }

        .winner-item {
            color: #fff59d; 
            font-weight: normal; 
            font-size: 0.95em;
            text-align: left;
            white-space: nowrap; 
        }

        table { width: 100%; border-collapse: collapse; text-align: center; min-width: 800px; }
        th, td { border: 1px solid #ddd; padding: 2px 1px; background: #fff; }
        thead th { background: #7f8c8d; color: white; }

        /* Â∑¶ÂÅ¥Ë≥áË®ä */
        .col-combined-header { width: 50px; background: #546e7a !important; color: white; font-size: 0.9em; }
        .col-combined-cell { border-right: 2px solid #ccc; padding: 2px !important; cursor: pointer; }
        .hole-val { font-size: 1.1em; font-weight: bold; }
        .hdcp-val { font-family: "Segoe UI Emoji", sans-serif; font-size: 1.0em; font-weight: 900; opacity: 0.9; }

        /* Â∫ïËâ≤Ë¶èÂâá */
        .bg-par-3 { background-color: #ffcdd2 !important; color: #b71c1c; } 
        .bg-par-3 .hole-val, .bg-par-3 .hdcp-val { color: #b71c1c; }
        .bg-par-4 { background-color: #ffffff !important; color: #333; } 
        .bg-par-4 .hole-val, .bg-par-4 .hdcp-val { color: #333; }
        .bg-par-5 { background-color: #bbdefb !important; color: #0d47a1; } 
        .bg-par-5 .hole-val, .bg-par-5 .hdcp-val { color: #0d47a1; }

        /* Á∑®ËºØÊ®°ÂºèÊ®£Âºè */
        @keyframes blink-red { 0% { color: red; opacity: 1; } 50% { color: red; opacity: 0.3; } 100% { color: red; opacity: 1; } }
        .editing-text { color: red !important; animation: blink-red 0.5s infinite; }
        
        .active-editing-row td { 
            border-top: 2px solid #fbc02d; 
            border-bottom: 2px solid #fbc02d; 
        }
        .active-editing-row td:not(.col-combined-cell) {
            background-color: #fff59d !important;
            color: #000;
        }

        /* Áé©ÂÆ∂Ê¨Ñ‰ΩçË®≠ÂÆö */
        .player-header { min-width: 91px; width: 91px; max-width: 91px; }
        .player-name-btn { background: none; border: 1px solid transparent; font-size: 0.95em; font-weight: bold; color: white; cursor: pointer; padding: 2px; width: 100%; border-radius: 4px; display: block; margin-bottom: 2px; min-height: 28px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .player-name-btn:hover { background-color: rgba(255,255,255,0.2); }
        .clickable-name { border: 1px dashed rgba(255,255,255,0.5); background: rgba(0,0,0,0.1); } 

        .info-row { display: flex; justify-content: center; align-items: center; gap: 1px; margin-bottom: 2px; }
        .handicap-btn { display: inline-block; background-color: #e8f4f8; border: 1px solid #b3d7ff; color: #0056b3; padding: 0 2px; border-radius: 6px; cursor: pointer; height: 20px; line-height: 18px; font-size: 0.8em; min-width: 30px; }
        .host-btn { display: inline-block; background-color: #fff3e0; border: 1px solid #ffe0b2; color: #ef6c00; padding: 0 2px; border-radius: 6px; height: 20px; line-height: 18px; font-size: 0.8em; cursor: default; }

        .stats-container { display: flex; justify-content: center; gap: 1px; margin-top: 2px; padding-top: 2px; border-top: 1px dashed rgba(255,255,255,0.3); }
        .stats-btn { width: 24px; height: 20px; font-size: 11px; font-weight: bold; border-radius: 3px; border: 1px solid #bdc3c7; background: #fff; display: flex; align-items: center; justify-content: center; cursor: default; color: #333; }
        .stats-ba { color: #e74c3c; border-color: #e74c3c; }
        .stats-bb { color: #2980b9; border-color: #2980b9; }
        .stats-bb.negative { color: red; background-color: #ffebee; }
        .stats-bb.positive { color: blue; background-color: #e3f2fd; }

        /* ÂàÜÊï∏ÊåâÈàïËàáÂåÖË£ùÂÆπÂô® */
        .score-cell-wrapper {
            position: relative; 
            display: inline-block;
        }

        .score-btn { 
            width: 40px; height: 38px; font-size: 1.3em; font-weight: bold; border-radius: 6px; 
            cursor: pointer; margin-bottom: 0px; transition: all 0.1s; background-color: #fff; 
            border: 1px dashed #ccc; color: #ccc; -webkit-user-select: none; padding: 0; 
        }
        .score-btn:active { transform: scale(0.95); }
        
        /* ÁçéÁõÉÂúñÁ§∫‰ΩçÁΩÆ */
        .trophy-icon {
            position: absolute;
            top: 50%;                
            left: -4px;              
            transform: translate(-100%, -50%); 
            font-size: 15px;
            z-index: 10;
            filter: drop-shadow(1px 1px 0px #fff) drop-shadow(-1px -1px 0px #fff); 
            pointer-events: none;
        }

        .style-par { background: #ffcc80; border: 1px solid #ef6c00; color: #000; }
        .style-bogey { border: 2px solid #000; color: #000; }
        .style-double-bogey { border: 2px solid #000; color: #000; box-shadow: inset 0 0 0 2px #fff, inset 0 0 0 4px #000; }
        .style-birdie { border: 2px solid red; color: red; border-radius: 50%; }
        .style-eagle { border: 2px solid red; color: red; border-radius: 50%; box-shadow: inset 0 0 0 2px #fff, inset 0 0 0 4px red; }

        /* BA/BB ÊåâÈàï */
        .sub-btn-container { display: flex; justify-content: center; gap: 4px; height: 26px; align-items: center; margin-top: 2px; }
        .btn-ba, .btn-bb { 
            width: 32px; height: 24px; background: #fff; border: 1px solid #ccc; 
            border-radius: 4px; font-weight: bold; font-size: 11px; padding: 0; 
            pointer-events: none; 
        }
        
        .btn-ba { cursor: pointer; pointer-events: auto; }
        .ba-initial { background: #fff; border-color: #999; color: #e74c3c; } 
        .ba-locked { background: #fff; border-color: #ddd; color: #ccc; cursor: not-allowed; }
        .ba-selected { background-color: #2e7d32 !important; border-color: #1b5e20 !important; color: white !important; }
        .ba-other { background: #c8e6c9; border-color: #81c784; color: #1b5e20; }
        
        .btn-bb { background: #f9f9f9; color: blue; } 
        .btn-bb.lose { color: red; }
        .btn-bb.handicap-applied { background-color: #ffe0e0 !important; border-color: #ffcccc !important; }

        tr.total-row td { background-color: #34495e !important; color: white; font-weight: bold; border-top: 2px solid #2c3e50; padding: 4px; vertical-align: middle; }
        .val-sub { font-size: 1.2em; color: #f1c40f; display:block; margin-bottom: 2px; line-height:1.1;} 
        .val-grand { font-size: 0.9em; color: #fff; border-top: 1px solid rgba(255,255,255,0.3); display:block; width: 80%; margin:0 auto; line-height:1.1;} 

        .pk-header { background: #e67e22; color: white; padding: 8px 12px; display: flex; align-items: center; gap: 10px; font-size: 1.2em; font-weight: bold; }
        .pk-hole-header { font-weight: bold; color: #333; min-width: 30px; font-size: 0.9em; }
        .pk-score-cell { font-size: 1.1em; font-weight: bold; width: 35px; height: 40px; vertical-align: middle; }
        
        /* PK Ê¨Ñ‰Ωç */
        .pk-name-cell { width: 120px; min-width: 120px; max-width: 120px; } 
        .pk-name-btn { 
            background: #f39c12; color: white; border: none; padding: 4px 4px; 
            border-radius: 4px; font-size: 1.0em; font-weight: bold; cursor: pointer; 
            width: 90px; min-width: 90px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
        }
        
        .pk-status { font-size: 0.9em; font-weight: bold; margin-top: 2px; }
        .pk-status.win { color: blue; } .pk-status.lose { color: red; }

        .custom-player-area { background: #fff; padding: 10px; margin: 10px auto; max-width: 100%; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .custom-input-group { display: flex; gap: 6px; flex-wrap: wrap; }
        .custom-input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex: 0 0 calc(50% - 3px); box-sizing: border-box; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 9999; }
        .modal-box { background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 400px; text-align: center; }
        .modal-buttons { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .modal-btn { padding: 10px; border: none; border-radius: 5px; font-size: 1em; cursor: pointer; }
    </style>
</head>
<body>

<div id="app">

    <div class="main-controls">
        <div class="control-group">
            <span class="label-text">ÁêÉÂ†¥:</span>
            <button class="action-btn" @click="toggleCourse">{{ currentCourseName }}</button>
        </div>
        
        <label class="edit-toggle-label">
            <input type="checkbox" v-model="isEditMode" style="margin-right:4px;"> Á∑®ËºØÁé©ÂÆ∂
        </label>

        <button class="btn-reset" @click="resetAllData">‚ö†Ô∏è Ê∏ÖÈô§ v79</button>

        <div class="control-group" style="margin-left:5px;">
            <span class="label-text">Ââç 9 :</span>
            <button class="zone-select-btn" @click="tryToggleZone('z1')">{{ currentZone1 }}</button>
        </div>

        <div class="control-group">
            <span class="label-text">Âæå 9 :</span>
            <button class="zone-select-btn" @click="tryToggleZone('z2')">{{ currentZone2 }}</button>
        </div>
    </div>

    <div class="card-container" v-for="zKey in ['z1', 'z2']" :key="zKey">
        <div class="zone-header">
            <div class="header-top">
                <span class="zone-title-text">{{ zKey === 'z1' ? 'Ââç 9' : 'Âæå 9' }}: {{ getZoneName(zKey) }}</span>
                <span class="summary-info">
                    ( Â∑≤ÈÄ≤Ë°å {{ getGlobalSummary().played }} Ê¥û , ÈÇÑÊúâ {{ getGlobalSummary().unclaimed }} Ê¥ûÊ≤í‰∫∫Êãø )
                </span>
            </div>
            <div class="winner-grid">
                <div v-for="leader in getGlobalSummary().leaders" class="winner-item">
                    {{ leader }}
                </div>
            </div>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th class="col-combined-header">Hole<br><span style="font-size:0.8em; opacity:0.8;">HDCP</span></th>
                    <th v-for="colIdx in 12" :key="colIdx-1" class="player-header">
                        <button class="player-name-btn" 
                                :class="{ 'clickable-name': isEditMode }"
                                @click="cyclePlayerName(colIdx-1)">
                            {{ columnNames[colIdx-1] || '...' }}
                        </button>
                        <div class="info-row">
                            <div v-if="colIdx === 1" class="host-btn">Áàê‰∏ª</div>
                            <div v-else class="handicap-btn" @click="toggleHandicap(colIdx-1, zKey)">ËÆì {{ handicaps[zKey][colIdx-1] }}</div>
                        </div>
                        <div class="stats-container">
                            <div class="stats-btn stats-ba" style="color:#e74c3c;">{{ countBA(colIdx-1, zKey) }}</div>
                            <div class="stats-btn stats-bb" 
                                 :class="{'positive': countBB(colIdx-1, zKey)>0, 'negative': countBB(colIdx-1, zKey)<0}">
                                {{ countBB(colIdx-1, zKey) > 0 ? '+' + countBB(colIdx-1, zKey) : countBB(colIdx-1, zKey) }}
                            </div>
                        </div>
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(hole, rIdx) in getZoneData(zKey).holes" :key="rIdx"
                    :class="{ 'active-editing-row': activeEditingRow?.zKey === zKey && activeEditingRow?.rIdx === rIdx }">
                    
                    <td class="col-combined-cell" 
                        :class="getParBgClass(getZoneData(zKey).par[rIdx])"
                        @click="handleHoleClick(zKey, rIdx)">
                        <div class="cell-content">
                            <div class="hole-val" :class="{ 'editing-text': isRowEditing(zKey, rIdx) }">{{ hole }}</div>
                            <div class="hdcp-val" :class="{ 'editing-text': isRowEditing(zKey, rIdx) }">
                                ‚õ≥ {{ getZoneData(zKey).hdcp[rIdx] }}
                            </div>
                        </div>
                    </td>

                    <td v-for="colIdx in 12" :key="colIdx-1">
                        <div class="score-cell-wrapper">
                            <div v-if="colIdx <= 4 && isUniqueLowScore(zKey, rIdx, colIdx)" class="trophy-icon">üèÜ</div>
                            
                            <button class="score-btn" 
                                    :class="[getScoreClass(scores[zKey][rIdx][colIdx-1], getZoneData(zKey).par[rIdx]), { 'locked-btn': !isRowEditing(zKey, rIdx) }]"
                                    @click.stop="updateScore(zKey, rIdx, colIdx-1)">
                                {{ scores[zKey][rIdx][colIdx-1] }}
                            </button>
                        </div>

                        <div class="sub-btn-container">
                            <button class="btn-ba" 
                                    :class="getBAClass(zKey, rIdx, colIdx-1)"
                                    @click="toggleBA(zKey, rIdx, colIdx-1)">
                                {{ baSelections[zKey][rIdx] === (colIdx-1) ? 'O' : '' }}
                            </button>
                            <button v-if="colIdx > 1" class="btn-bb" 
                                    :class="getBBClass(zKey, rIdx, colIdx-1)">
                                {{ calculateBB(zKey, rIdx, colIdx-1).text }}
                            </button>
                        </div>
                    </td>
                </tr>

                <tr class="total-row">
                    <td>{{ zKey === 'z1' ? 'Ââç 9' : 'Âæå 9' }}<br>Á∏ΩÊ°ø</td>
                    <td v-for="colIdx in 12" :key="colIdx-1">
                        <div class="total-display-container">
                            <span class="val-sub">{{ calculateGross(zKey, colIdx-1) }}</span>
                            <span class="val-grand">{{ calculateGrandTotal(colIdx-1) }}</span>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="card-container" style="border: 2px solid #e67e22;">
        <div class="pk-header"><span>‚öîÔ∏è PK Â∞àÂçÄ</span></div>
        <table>
            <thead>
                <tr>
                    <th style="min-width:60px;">Ââç 9</th>
                    <th v-for="(hole, i) in getZoneData('z1').holes" :key="i" class="pk-hole-header" :class="getParBgClass(getZoneData('z1').par[i])">{{ hole }}</th>
                    <th>Total</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="pk-name-cell">
                        <button class="pk-name-btn" @click="togglePkPlayer(1)">{{ pk.p1 }}</button>
                        <div class="host-btn" style="margin-top:2px; font-size:0.8em;">Áàê‰∏ª</div>
                        <div class="pk-status" :class="pkResults.f9.p1Cls">{{ pkResults.f9.p1Txt }}</div>
                    </td>
                    <td v-for="(val, i) in pkResults.f9.scores.p1" :key="i" class="pk-score-cell" :class="getScoreClass(val, getZoneData('z1').par[i])">{{ val }}</td>
                    <td style="font-weight:bold;">{{ pkResults.f9.totals.p1 || '' }}</td>
                </tr>
                <tr>
                    <td class="pk-name-cell">
                        <button class="pk-name-btn" @click="togglePkPlayer(2)">{{ pk.p2 }}</button>
                        <div class="handicap-btn" style="margin-top:2px; font-size:0.8em;" @click="togglePkHdcp('f9')">ËÆì {{ pk.hdcp_f9 }}</div>
                        <div class="pk-status" :class="pkResults.f9.p2Cls">{{ pkResults.f9.p2Txt }}</div>
                    </td>
                    <td v-for="(val, i) in pkResults.f9.scores.p2" :key="i" class="pk-score-cell" :class="getScoreClass(val, getZoneData('z1').par[i])">{{ val }}</td>
                    <td style="font-weight:bold;">{{ pkResults.f9.totals.p2 || '' }}</td>
                </tr>
            </tbody>
            <thead style="border-top: 3px solid #e67e22;">
                <tr>
                    <th>Âæå 9</th>
                    <th v-for="(hole, i) in getZoneData('z2').holes" :key="i" class="pk-hole-header" :class="getParBgClass(getZoneData('z2').par[i])">{{ hole }}</th>
                    <th>Total</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="pk-name-cell"><span style="font-weight:bold;">{{ pk.p1 }}</span><div class="pk-status" :class="pkResults.b9.p1Cls">{{ pkResults.b9.p1Txt }}</div></td>
                    <td v-for="(val, i) in pkResults.b9.scores.p1" :key="i" class="pk-score-cell" :class="getScoreClass(val, getZoneData('z2').par[i])">{{ val }}</td>
                    <td style="font-weight:bold;">{{ pkResults.b9.totals.p1 || '' }}</td>
                </tr>
                <tr>
                    <td class="pk-name-cell"><span style="font-weight:bold;">{{ pk.p2 }}</span><div class="handicap-btn" style="margin-top:2px; font-size:0.8em;" @click="togglePkHdcp('b9')">ËÆì {{ pk.hdcp_b9 }}</div><div class="pk-status" :class="pkResults.b9.p2Cls">{{ pkResults.b9.p2Txt }}</div></td>
                    <td v-for="(val, i) in pkResults.b9.scores.p2" :key="i" class="pk-score-cell" :class="getScoreClass(val, getZoneData('z2').par[i])">{{ val }}</td>
                    <td style="font-weight:bold;">{{ pkResults.b9.totals.p2 || '' }}</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="custom-player-area">
        <span style="font-weight:bold; color:#555; display:block; margin-bottom:5px;">ÈùûÂÆöÁæ©Áé©ÂÆ∂ (Ëº∏ÂÖ•ÂæåËá™ÂãïÂä†ÂÖ•ÂêçÂñÆ)</span>
        <div class="custom-input-group">
            <input v-for="(name, idx) in customPlayers" :key="idx" type="text" class="custom-input" 
                   v-model="customPlayers[idx]" :placeholder="'Áé©ÂÆ∂ ' + String.fromCharCode(65+idx)">
        </div>
    </div>

    <div v-if="showZoneModal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-title">‚ö†Ô∏è Ë©≤ÁêÉÈÅìÂ∑≤ÊúâË≥áÊñô</div>
            <div class="modal-buttons">
                <button class="modal-btn" style="background:#2980b9; color:white;" @click="confirmZoneChange(false)">‰øùÁïôË≥áÊñô</button>
                <button class="modal-btn" style="background:#e67e22; color:white;" @click="confirmZoneChange(true)">Ê∏ÖÈô§Ë≥áÊñô</button>
                <button class="modal-btn" style="background:#95a5a6; color:white;" @click="showZoneModal = false">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

</div>

<script>
    const { createApp, reactive, computed, watch, onMounted, toRefs } = Vue;

    createApp({
        setup() {
            const STORAGE_KEY = 'golf_scorecard_v79_fixed_index';
            const basePlayers = ["ÂºµÁ∞°Ê¶ÆÂäõ", "Ê¥™Âø†ÂÆú", "Èô≥ÊåØÂ≥Ø", "Ë∂ôÊåØÊòé", "ÊùéÂ≠êÁëã", "ÂºµÂòâÂéü", "Â∑´ÂêâÁîü", "Âê≥Âª∫Ëºù", "ÊûóÊîøÁø∞", "Èô≥Â®ÅÂÆá", "ËåÉÁßÄËò≠", "Ë¨ùÊóºÈÅî", "È´òÂè∞Áéâ", "ÂºµÈäòÂæ∑"];
            
            const state = reactive({
                currentCourseName: "Âè∞‰∏≠ÂúãÈöõ",
                currentZone1: "Êù±ÂçÄ",
                currentZone2: "Ë•øÂçÄ",
                isEditMode: false,
                customPlayers: ["", "", "", ""],
                activeEditingRow: null,
                showZoneModal: false,
                pendingZoneChange: null,
                
                scores: {
                    z1: Array(9).fill().map(() => Array(12).fill("")),
                    z2: Array(9).fill().map(() => Array(12).fill(""))
                },
                
                baSelections: {
                    z1: Array(9).fill(null),
                    z2: Array(9).fill(null)
                },

                handicaps: {
                    z1: Array(12).fill(4),
                    z2: Array(12).fill(4)
                },

                columnNames: Array(12).fill("").map((_, i) => i < 4 ? basePlayers[i] : ""),

                pk: { p1: basePlayers[0], p2: basePlayers[1], hdcp_f9: 4, hdcp_b9: 4 }
            });

            const courseDB = {
                "Âè∞‰∏≠ÂúãÈöõ": {
                    "Êù±ÂçÄ": { holes: ["Êù±1","Êù±2","Êù±3","Êù±4","Êù±5","Êù±6","Êù±7","Êù±8","Êù±9"], par: [4,4,3,5,4,4,3,5,4], hdcp: [2,8,5,4,7,1,9,3,6] },
                    "‰∏≠ÂçÄ": { holes: ["‰∏≠1","‰∏≠2","‰∏≠3","‰∏≠4","‰∏≠5","‰∏≠6","‰∏≠7","‰∏≠8","‰∏≠9"], par: [4,4,3,5,4,4,3,4,5], hdcp: [7,2,8,5,4,1,9,3,6] },
                    "Ë•øÂçÄ": { holes: ["Ë•ø1","Ë•ø2","Ë•ø3","Ë•ø4","Ë•ø5","Ë•ø6","Ë•ø7","Ë•ø8","Ë•ø9"], par: [5,4,3,4,4,3,4,5,4], hdcp: [3,6,9,8,1,4,7,2,5] }
                },
                "Ë±êÂéüÁêÉÂ†¥": {
                    "OUT": { holes: ["1","2","3","4","5","6","7","8","9"], par: [4,5,5,3,4,4,3,4,3], hdcp: [5,3,7,15,1,9,17,11,13] },
                    "IN": { holes: ["10","11","12","13","14","15","16","17","18"], par: [5,3,4,3,4,3,5,4,5], hdcp: [4,18,2,16,10,14,12,6,8] }
                },
                "ÂΩ∞ÂåñÁêÉÂ†¥": {
                    "OUT": { holes: ["1","2","3","4","5","6","7","8","9"], par: [5,3,4,4,4,5,4,4,3], hdcp: [3,17,1,11,7,13,9,5,15] },
                    "IN": { holes: ["10","11","12","13","14","15","16","17","18"], par: [5,3,4,4,4,4,3,5,5], hdcp: [4,16,2,18,6,8,14,10,12] }
                },
                "Ê∏ÖÊ≥âÂ¥óÁêÉÂ†¥": {
                    "OUT": { holes: ["1","2","3","4","5","6","7","8","9"], par: [4,4,4,3,4,4,5,4,4], hdcp: [11,1,5,9,3,15,7,13,17] },
                    "IN": { holes: ["10","11","12","13","14","15","16","17","18"], par: [4,3,4,5,4,4,5,3,4], hdcp: [4,12,16,8,10,2,6,18,14] }
                },
                "ÂÖ®ÂúãÁêÉÂ†¥": {
                    "OUT": { holes: ["1","2","3","4","5","6","7","8","9"], par: [4,4,5,4,3,4,5,3,4], hdcp: [17,11,9,5,13,1,3,15,7] },
                    "IN": { holes: ["10","11","12","13","14","15","16","17","18"], par: [4,3,4,5,3,4,5,4,4], hdcp: [18,16,12,10,14,2,4,6,8] }
                },
                "ÂçóÂ≥∞ÁêÉÂ†¥": {
                    "OUT": { holes: ["1","2","3","4","5","6","7","8","9"], par: [5,4,4,3,4,4,3,5,4], hdcp: [3,9,15,13,5,1,17,11,7] },
                    "IN": { holes: ["10","11","12","13","14","15","16","17","18"], par: [5,3,4,4,3,4,5,4,4], hdcp: [4,18,10,6,14,2,8,12,16] }
                }
            };

            const allPlayerNames = computed(() => {
                const extras = state.customPlayers.filter(n => n !== "");
                return [...basePlayers, ...extras];
            });

            const getZoneData = (zKey) => {
                const zoneName = zKey === 'z1' ? state.currentZone1 : state.currentZone2;
                return courseDB[state.currentCourseName][zoneName] || { holes:[], par:[], hdcp:[] };
            };

            const getValidPkCandidates = () => {
                let candidates = [];
                state.columnNames.forEach((name, colIdx) => {
                    if (!name) return;
                    const hasScoreZ1 = state.scores.z1.some(row => row[colIdx] !== "");
                    const hasScoreZ2 = state.scores.z2.some(row => row[colIdx] !== "");
                    if (hasScoreZ1 || hasScoreZ2) {
                        candidates.push(name);
                    }
                });
                return candidates;
            };

            const calculateBB = (zKey, rIdx, colIdx) => {
                if (!state.columnNames[colIdx]) return { text: '', isHdcp: false };
                if (colIdx === 0) return { text: '', isHdcp: false }; 
                
                const zData = getZoneData(zKey);
                const s1 = parseInt(state.scores[zKey][rIdx][0]); 
                const s2 = parseInt(state.scores[zKey][rIdx][colIdx]); 
                const hdcpVal = zData.hdcp[rIdx]; 
                const userHandicap = state.handicaps[zKey][colIdx]; 

                const sortedHdcp = [...zData.hdcp].sort((a, b) => a - b);
                let cutoffHdcp = 0;
                if (userHandicap > 0) {
                    let safeIdx = Math.min(userHandicap, 9) - 1;
                    cutoffHdcp = sortedHdcp[safeIdx];
                }
                
                const isHdcp = (hdcpVal <= cutoffHdcp);

                if (isNaN(s1) || isNaN(s2)) return { text: '', isHdcp };

                let netS2 = s2 - (isHdcp ? 1 : 0);
                let diff = '';
                
                if (netS2 < s1) {
                    let pts = (s2 < zData.par[rIdx]) ? 2 : 1; 
                    diff = `+${pts}`;
                } else if (netS2 > s1) {
                    let pts = (s1 < zData.par[rIdx]) ? 2 : 1;
                    diff = `-${pts}`;
                }
                
                return { text: diff, isHdcp };
            };

            const pkResults = computed(() => {
                const calc = (zKey, p1Name, p2Name, p2Hdcp) => {
                    const zData = getZoneData(zKey);
                    let p1Scores = [], p2Scores = [];
                    let netTotal = 0;
                    let p1Total = 0, p2Total = 0;

                    let p1Col = state.columnNames.indexOf(p1Name);
                    let p2Col = state.columnNames.indexOf(p2Name);

                    const sortedHdcp = [...zData.hdcp].sort((a,b)=>a-b);
                    let cutoff = (p2Hdcp > 0) ? sortedHdcp[Math.min(p2Hdcp,9)-1] : 0;

                    for(let i=0; i<9; i++) {
                        let s1 = (p1Col>=0) ? parseInt(state.scores[zKey][i][p1Col]) : NaN;
                        let s2 = (p2Col>=0) ? parseInt(state.scores[zKey][i][p2Col]) : NaN;
                        p1Scores.push(isNaN(s1)?'':s1);
                        p2Scores.push(isNaN(s2)?'':s2);
                        if(!isNaN(s1)) p1Total += s1;
                        if(!isNaN(s2)) p2Total += s2;

                        if(!isNaN(s1) && !isNaN(s2)) {
                            let isHdcp = zData.hdcp[i] <= cutoff;
                            let netS2 = s2 - (isHdcp ? 1 : 0);
                            if(netS2 < s1) netTotal += (s2 < zData.par[i] ? 2 : 1);
                            else if(netS2 > s1) netTotal -= (s1 < zData.par[i] ? 2 : 1);
                        }
                    }
                    
                    let p1Txt="Âπ≥Êâã", p2Txt="Âπ≥Êâã", p1Cls="", p2Cls="";
                    if(netTotal > 0) { p2Txt=`Ë¥è ${netTotal} Ê¥û`; p2Cls="win"; p1Txt=`Ëº∏ ${netTotal} Ê¥û`; p1Cls="lose"; }
                    else if(netTotal < 0) { p1Txt=`Ë¥è ${Math.abs(netTotal)} Ê¥û`; p1Cls="win"; p2Txt=`Ëº∏ ${Math.abs(netTotal)} Ê¥û`; p2Cls="lose"; }

                    return { scores: {p1: p1Scores, p2: p2Scores}, totals: {p1: p1Total, p2: p2Total}, p1Txt, p1Cls, p2Txt, p2Cls };
                };

                return {
                    f9: calc('z1', state.pk.p1, state.pk.p2, state.pk.hdcp_f9),
                    b9: calc('z2', state.pk.p1, state.pk.p2, state.pk.hdcp_b9)
                };
            });

            // ================= METHODS =================

            const toggleCourse = () => {
                const courses = Object.keys(courseDB);
                let idx = courses.indexOf(state.currentCourseName);
                let nextIdx = (idx + 1) % courses.length;
                state.currentCourseName = courses[nextIdx];
                const zones = Object.keys(courseDB[state.currentCourseName]);
                state.currentZone1 = zones[0];
                state.currentZone2 = zones.length > 1 ? zones[1] : zones[0];
            };

            const tryToggleZone = (zKey) => {
                const hasData = state.scores[zKey].some(row => row.some(val => val !== ""));
                const zones = Object.keys(courseDB[state.currentCourseName]);
                const currentZ = zKey === 'z1' ? state.currentZone1 : state.currentZone2;
                const nextZ = zones[(zones.indexOf(currentZ) + 1) % zones.length];

                if (hasData) {
                    state.pendingZoneChange = { zKey, nextZone: nextZ };
                    state.showZoneModal = true;
                } else {
                    if (zKey === 'z1') state.currentZone1 = nextZ;
                    else state.currentZone2 = nextZ;
                }
            };

            const confirmZoneChange = (shouldClear) => {
                const { zKey, nextZone } = state.pendingZoneChange;
                if (zKey === 'z1') state.currentZone1 = nextZone;
                else state.currentZone2 = nextZone;
                if (shouldClear) {
                    state.scores[zKey] = Array(9).fill().map(() => Array(12).fill(""));
                    state.baSelections[zKey] = Array(9).fill(null);
                }
                state.showZoneModal = false;
            };

            const handleHoleClick = (zKey, rIdx) => {
                if (state.activeEditingRow && state.activeEditingRow.zKey === zKey && state.activeEditingRow.rIdx === rIdx) {
                    state.activeEditingRow = null; 
                } else {
                    state.activeEditingRow = { zKey, rIdx }; 
                    const rowScores = state.scores[zKey][rIdx];
                    const hasAnyScore = rowScores.some(s => s !== "");
                    
                    if (!hasAnyScore) {
                        const par = getZoneData(zKey).par[rIdx];
                        state.columnNames.forEach((name, i) => {
                            if(name) state.scores[zKey][rIdx][i] = par;
                        });
                    }
                }
            };

            const updateScore = (zKey, rIdx, colIdx) => {
                if (!isRowEditing(zKey, rIdx)) return;
                if (!state.columnNames[colIdx]) return;

                let curr = state.scores[zKey][rIdx][colIdx];
                let next;
                
                const par = getZoneData(zKey).par[rIdx];
                let limit = 9;
                if (par === 3) limit = 6;
                else if (par === 4) limit = 8;

                if (curr === "") next = 1;
                else {
                    next = parseInt(curr) + 1;
                    if (next > limit) next = "";
                }
                state.scores[zKey][rIdx][colIdx] = next;
            };

            const toggleBA = (zKey, rIdx, colIdx) => {
                if (!isRowEditing(zKey, rIdx)) return;
                
                if (state.baSelections[zKey][rIdx] === colIdx) {
                    state.baSelections[zKey][rIdx] = null; 
                } else {
                    state.baSelections[zKey][rIdx] = colIdx; 
                }
            };

            const calculateGross = (zKey, colIdx) => {
                let total = 0;
                for(let i=0; i<9; i++) {
                    let s = parseInt(state.scores[zKey][i][colIdx]);
                    if(!isNaN(s)) total += s;
                }
                return total > 0 ? total : 0;
            };

            const calculateGrandTotal = (colIdx) => {
                return calculateGross('z1', colIdx) + calculateGross('z2', colIdx);
            };

            const countBA = (colIdx, zKey) => {
                return state.baSelections[zKey].filter(sel => sel === colIdx).length;
            };

            const countBB = (colIdx, zKey) => {
                let total = 0;
                for(let i=0; i<9; i++) {
                    let bb = calculateBB(zKey, i, colIdx);
                    if(bb.text.startsWith('+')) total += parseInt(bb.text.replace('+',''));
                    else if(bb.text.startsWith('-')) total -= parseInt(bb.text.replace('-',''));
                }
                return total;
            };

            const getZoneName = (zKey) => zKey === 'z1' ? state.currentZone1 : state.currentZone2;
            const isRowEditing = (zKey, rIdx) => state.activeEditingRow?.zKey === zKey && state.activeEditingRow?.rIdx === rIdx;
            
            const getParBgClass = (par) => {
                if (par === 3) return 'bg-par-3';
                if (par === 5) return 'bg-par-5';
                return 'bg-par-4';
            };

            const getScoreClass = (score, par) => {
                if(!score) return '';
                let s = parseInt(score);
                let diff = s - par;
                if(diff===0) return 'style-par';
                if(diff===1) return 'style-bogey';
                if(diff>=2) return 'style-double-bogey';
                if(diff===-1) return 'style-birdie';
                if(diff<=-2) return 'style-eagle';
                return '';
            };
            const getBBClass = (zKey, rIdx, colIdx) => {
                let bb = calculateBB(zKey, rIdx, colIdx);
                let cls = [];
                if(bb.text.startsWith('+')) cls.push('win');
                else if(bb.text.startsWith('-')) cls.push('lose');
                if(bb.isHdcp) cls.push('handicap-applied');
                return cls;
            };

            const getBAClass = (zKey, rIdx, colIdx) => {
                const selectedIdx = state.baSelections[zKey][rIdx];
                if (selectedIdx === colIdx) return 'ba-selected'; 
                if (selectedIdx !== null) return 'ba-other';    
                if (!isRowEditing(zKey, rIdx)) return 'ba-locked';
                return 'ba-initial';
            };

            // ‚òÖ v79 ‰øÆÊ≠£Ôºö‰øÆÊ≠£ÂπΩÈùàÁçéÁõÉ + ‰øÆÊ≠£index
            const isUniqueLowScore = (zKey, rIdx, colIdx) => {
                const myIdx = colIdx - 1; // ‰øÆÊ≠£ index: colIdx ÊòØ 1-based, myIdx ÊòØ 0-based
                let myScoreStr = state.scores[zKey][rIdx][myIdx];
                
                // 1. Ê™¢Êü•Ëá™Â∑±ÊúâÁÑ°ÂàÜÊï∏ (‰øÆÂæ©ÂπΩÈùàÁçéÁõÉ)
                if (myIdx >= 4 || !state.columnNames[myIdx] || myScoreStr === "") return false;

                const zData = getZoneData(zKey);
                const holeHdcp = zData.hdcp[rIdx];
                const myGross = parseInt(myScoreStr);
                
                // Âº∑Âà∂ P1 ËÆìÊ°øÁÇ∫ 0
                const myHdcp = (myIdx === 0) ? 0 : state.handicaps[zKey][myIdx];

                // 2. ÂÖ©ÂÖ©ÊØîÂ∞ç
                for (let i = 0; i < 4; i++) {
                    if (i === myIdx) continue; // ‰∏çË∑üËá™Â∑±ÊØî

                    let oppScoreStr = state.scores[zKey][rIdx][i];
                    if (!state.columnNames[i] || oppScoreStr === "") continue;

                    let oppGross = parseInt(oppScoreStr);
                    let oppHdcp = (i === 0) ? 0 : state.handicaps[zKey][i];

                    let diff = Math.abs(myHdcp - oppHdcp);
                    let myNet = myGross;
                    let oppNet = oppGross;

                    if (holeHdcp <= diff) {
                        if (myHdcp > oppHdcp) {
                            myNet -= 1;
                        } else if (oppHdcp > myHdcp) {
                            oppNet -= 1;
                        }
                    }

                    if (myNet >= oppNet) {
                        return false;
                    }
                }
                
                return true;
            };

            const cyclePlayerName = (colIdx) => {
                if(!state.isEditMode) return;
                
                let currentName = state.columnNames[colIdx];
                let allOptions = [...allPlayerNames.value, ""]; 
                
                let idx = allOptions.indexOf(currentName);
                if (idx === -1) idx = -1; 
                
                let nextName = allOptions[(idx + 1) % allOptions.length];
                state.columnNames[colIdx] = nextName;
            };

            const toggleHandicap = (colIdx, zKey) => {
                let h = state.handicaps[zKey][colIdx];
                state.handicaps[zKey][colIdx] = (h >= 9) ? 0 : h + 1;
            };

            const togglePkPlayer = (pNum) => {
                const candidates = getValidPkCandidates();
                if (candidates.length === 0) {
                    alert("Ê≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑÁé©ÂÆ∂ (ÈúÄÂú®Ë°®Ê†º‰∏≠‰∏îËá≥Â∞ëÊúâ‰∏ÄÊ¥ûÂàÜÊï∏)");
                    return;
                }

                let curr = pNum === 1 ? state.pk.p1 : state.pk.p2;
                let idx = candidates.indexOf(curr);
                
                let next;
                if (idx === -1) next = candidates[0];
                else next = candidates[(idx + 1) % candidates.length];

                if(pNum === 1) state.pk.p1 = next; else state.pk.p2 = next;
            };

            const togglePkHdcp = (zone) => {
                if(zone==='f9') state.pk.hdcp_f9 = state.pk.hdcp_f9 >=9 ? 0 : state.pk.hdcp_f9+1;
                else state.pk.hdcp_b9 = state.pk.hdcp_b9 >=9 ? 0 : state.pk.hdcp_b9+1;
            };

            const getGlobalSummary = () => {
                let played = 0;
                let unclaimed = 0;
                let baCounts = {}; 
                let totalBAWins = 0; 
                let activePlayers = []; 

                state.columnNames.forEach((name, colIdx) => {
                    if (name) {
                        activePlayers.push(colIdx);
                        baCounts[colIdx] = 0; 
                    }
                });

                ['z1', 'z2'].forEach(zKey => {
                    for (let i = 0; i < 9; i++) {
                        const hasScore = state.scores[zKey][i].some(s => s !== "");
                        if (hasScore) {
                            played++;
                            const winnerIdx = state.baSelections[zKey][i];
                            if (winnerIdx === null) {
                                unclaimed++;
                            } else {
                                if (baCounts[winnerIdx] !== undefined) {
                                    baCounts[winnerIdx]++;
                                    totalBAWins++;
                                }
                            }
                        }
                    }
                });

                let N = activePlayers.length; 

                let leaders = [];
                activePlayers.forEach(colIdx => {
                    let wins = baCounts[colIdx];
                    let net = (wins * (N - 1)) - (totalBAWins - wins);
                    let name = state.columnNames[colIdx];
                    leaders.push(`${name} Ë¥è ${wins} Ê¥û [ ${net} ]`);
                });

                return {
                    played,
                    unclaimed, 
                    leaders 
                };
            };

            const saveData = () => {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            };
            
            const loadData = () => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (!parsed.columnNames) {
                        parsed.columnNames = Array(12).fill("").map((_, i) => i < 4 ? basePlayers[i] : "");
                    }
                    if (Array.isArray(parsed.handicaps)) {
                        parsed.handicaps = { z1: Array(12).fill(4), z2: Array(12).fill(4) };
                    }
                    ['z1', 'z2'].forEach(k => {
                        parsed.scores[k] = parsed.scores[k].map(row => {
                            if (row.length < 12) return [...row, ...Array(12 - row.length).fill("")];
                            return row;
                        });
                    });

                    Object.assign(state, parsed);
                }
            };

            const resetAllData = () => {
                if(confirm("Á¢∫ÂÆöÊ∏ÖÈô§ÊâÄÊúâÁ¥ÄÈåÑ?")) {
                    state.scores.z1 = Array(9).fill().map(() => Array(12).fill(""));
                    state.scores.z2 = Array(9).fill().map(() => Array(12).fill(""));
                    state.baSelections.z1 = Array(9).fill(null);
                    state.baSelections.z2 = Array(9).fill(null);
                    state.columnNames = Array(12).fill("").map((_, i) => i < 4 ? basePlayers[i] : "");
                    state.handicaps = { z1: Array(12).fill(4), z2: Array(12).fill(4) };
                    saveData();
                }
            };

            watch(state, () => {
                saveData();
            }, { deep: true });

            onMounted(() => {
                loadData();
            });

            return {
                ...toRefs(state),
                allPlayerNames,
                courseDB,
                toggleCourse,
                tryToggleZone,
                confirmZoneChange,
                handleHoleClick,
                updateScore,
                toggleBA,
                calculateGross,
                calculateGrandTotal,
                countBA,
                countBB,
                getZoneName,
                getZoneData,
                isRowEditing,
                getParBgClass,
                getScoreClass,
                calculateBB,
                getBBClass,
                getBAClass,
                cyclePlayerName,
                toggleHandicap,
                togglePkPlayer,
                togglePkHdcp,
                pkResults,
                resetAllData,
                getGlobalSummary,
                isUniqueLowScore // ÂåØÂá∫Êñ∞ÂáΩÊï∏
            };
        }
    }).mount('#app');
</script>
</body>
</html>
